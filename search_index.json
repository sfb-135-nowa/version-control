[["index.html", "Version Control with Git Welcome Overview", " Version Control with Git Tamara Cook, M.Sc1 29.06.2021 Welcome You are visiting the written version of a course about integrating version control using Git into research projects. This course was initially created for the members of the CRC 135 and their scientific staff within the CRC’s NOWA project. Overview The course is divided into two parts: Concepts of version control and basic workflows Project customization and collaboration Concepts of version control and basic workflows In this session, the participants familiarize themselves with version control as a working method and get the opportunity to practice the basic Git workflows. They will be able to: Explore existing Git repositories, browse the version history, compare versions, extract data from older versions Edit data in a repo and add new versions,, make use of Git’s features for parallel working contexts Decide if Git is suitable for their needs Project customization and Gitlab In this session, the scope extends to collaboration on Gitlab projects. These topics are covered: Connecting Git repos with Gitlab and uploading work for backup Customizing Git repos for the project content Sharing Gitlab projects with co-workers for review Collaborating with co-workers on a shared Gitlab project Philipps-Universität Marburg Fachbereich Psychologie (FB06) AG Allgemeine und Biologische Psychologie Email: tamara.cook@uni-marburg.de↩︎ "],["organization.html", "1 Organization 1.1 Agenda", " 1 Organization In this session, the participants familiarize themselves with version control as a working method and get the opportunity to practice the basic Git workflows. They will be able to: Explore existing Git repositories, browse the version history, compare versions, extract data from older versions Edit data in a repo and add new versions,, make use of Git’s features for parallel working contexts Decide if Git is suitable for their needs 1.1 Agenda 14:00 Talk: Welcome, strengths and weaknesses of version control, software 14:20 Practice: Software setup 14:30 Talk: Git repositories and their decentralized nature 14:45 Practice: Cloning repositories, autentification with Gitlab 15:00 Talk: Understanding the Git versioning structure (commits, tags, and branches) 15:30 Practice: Browsing the Git history, answering questions 16:00 Talk: The basic editing workflow 16:30 Practice: Working and versioning, answering questions "],["motivation.html", "2 Motivation 2.1 Meaningful versions 2.2 Version history and comparing versions 2.3 Parallel work 2.4 Fast and reliable 2.5 Working with remotes 2.6 Flexibility and separation of concerns 2.7 General and special tools", " 2 Motivation In this introductory chapter, you will learn what makes version control with git so special, and how it can be useful for research projects 2.1 Meaningful versions Git doesn’t create automatic time-based backups, but the user actively decides to create versions after introducing changes to the project files. The user decides when a new version is created and which changes should go into that version. This makes it possible to group changes into sets that represent a higher-level action, meaningful versions. In addition, each version contains some metadata like author, creation date, and a user-provided description. 2.2 Version history and comparing versions The version history can be viewed and each version can be completely or partially restored,. Instead of having many independent file copies, each version represents a full project state. So the project can be reset to any versioned state in the past. The version history can be subsetted, e.g. to show only versions that changed a given file. Versions cannot only be restored or viewed invididually, but it’s also possible to compare versions or individual files in different versions. Change sets are essential for version creation, but they are also used for retrospectively viewing which changes were introduced by a version and for version comparisons. Normally, versions are not deleted. It is possible to rewrite or delete versions, but this has to be done deliberately and doesn’t happen by mistake. 2.3 Parallel work Git allows for easily creating diverging parallel working contexts in one project which can also be reintegrated. A context can adopt the work from another context. This supports a large amount of different working scenarios: Collaboration without overwriting each other’s work Trying out different approaches without poluting the main project Maintaining multiple variants of a product, e.g., a series of psychophysical experiments 2.4 Fast and reliable It might come to mind that these operations like restoring versions or copying work from contexts must be slow and heavy. But they are extremely fast and reliable, because git doesn’t need to move file copies around. Git doesn’t interrupt your workflow with “Copying 20,000 files,” and projects rarely become corrupted by themselves. Of course a project can result in a strange state by improper usage, but it rarely breaks randomly. 2.5 Working with remotes A git project can be copied to a remote server. This supports several working scenarios: Backup You can successively upload your local work to the remote copy on the server and download it on another computer. Sharing You can share the project with the public or with team members for reuse or review. Collaboration You can collaborate with your team members or co-workers on the project. 2.6 Flexibility and separation of concerns Git is very flexible in terms of versioned content and working environment. It doesn’t make many assumptions about the content, thus it can be used for any content type (code, text, data), but some functionalities work better with text files than with binary files because it was originally created for source code and not for binary artefacts. One implication of this content agnosticity is that it always works the same way and follows the same principles. If you have once learned its usage, you have acquired highly reusable knowledge that can also be a valuable occupational skill. Besides, git is less interweaved with your productivity tools, thus you get a clear separation between being productive and versioning your work. Because git is not just a program but a technology, there is a range of different git frontends for a variety of environments. You can choose what best fits your needs. The traditional command line tool Graphical standalone clients like Git Tower or GitKraken IDE integrations, e.g. in VS Code or IntelliJ 2.7 General and special tools Git is a brilliant version control system, but it is also an enormous collection of tools developed by ambitious people who wanted to solve very specific problems the most efficient way. For most problems, a highly optimized but specialized solution exists somewhere in the mess of details. This course aims to introduce a consistent concept model and a subset of general-use tools which can be intuitively combined to accomplish most usual workflow tasks. You will be able to extend your skills with more specific solutions, as soon as you want to become more efficient. "],["inspecting-version-history.html", "3 Inspecting version history 3.1 Repository 3.2 Remote repos and distributed git 3.3 Commit history 3.4 Navigating the tree: Tags and branches 3.5 Comparing commits", " 3 Inspecting version history This chapter describes the building blocks of a git project and how the version history of an existing git project can be inspected. This can even be useful if you decide not to use git in your projects. 3.1 Repository A repository (repo) is simply a hidden physical folder named .git which contains a version history in the git-specific file structure and data formats. It can sit somewhere on your local machine or on a server. In general, git assumes that the folder which contains the repo is the root folder of your actual project where you work with your files and that you want to put under version control. So a project that is versioned with git mostly contains a .git folder. When a project folder is put under version control and gets a .git folder, this folder is managed by git and is called worktree or working copy. The content of the work tree is simply a copy of the most recent version. It is the place where authors work on their project and introduce their changes to git by creating new versions. In this chapter, we are only interested in the version history which can be completely inspected without touching the working copy. It is important to understand that the history is the essential core part, whereas the working copy is more like a writing channel to the repo. There is even a repo variant with no working copy for situations when a repo is not used for creating new versions. The working copy will be the central part of the workflow chapter. 3.2 Remote repos and distributed git Each repo can store URL references to one or more other repos (from servers, colleagues, etc.) and fetch their complete version history. These references are called remotes, and it’s no problem to fetch multiple version histories. An URL exactly points to where a .git directory is located. Git is decentralized or distributed, which means that it actually doesn’t know the concept of a central main repo. You could even reference each other and fetch each other’s work, but the more common workflow is to build a centralized structure by having a repo on a server where every collaborator can fetch from and where new versions can be pushed to. Git only talks to the remotes when you want to fetch or push new versions. The actual work is always done locally, so it remains quick, and if the server would crash, you still have the complete history and were able to copy it to the server again. 3.2.1 Cloning as a common shortcut If you discover an interesting repo on a server, you might want to view it locally. You could manually create a new local repo, add the remote, fetch its history, and restore its most recent version to the working copy. Because this is such a usual process, it became a combined git concept named cloning. The materials and sources for this course book are versioned in a Git repository themselves. First, you will have to clone it from Github, because this repo is used for the exercises. Please visit the course repository on Github. This is just the page URL and not necessarily the actual repo URL. Cloning is such a common first step that hosting platforms provide a download button which lets you copy the correct repo URL. On Github, this is hidden behind the Download icon above the files list. Please copy the HTTPS URL to the clipboard. In Git tower, go to File menu -&gt; Clone git repository, paste the repo URL in the dialog, and find or create a folder which should be the project folder. After cloning is done, go to Repository view and open the newly cloned repository which should appear on top of the list. On the command line, open a terminal in the directory that should contain the project, and run git clone &lt;REPO_URL&gt; &lt;PROJECT_FOLDER&gt;. If you omit the second parameter, the name will be the repo name from Github. 3.2.2 Authentication with protected repos If a repo can be publicly viewed, you wont have any problems to clone it. But if the access is restricted or you want to push to the repo, you will have to create an account for the respective platform and setup authentication. Git supports two network protocols for remote operations, and both have their own authentication strategies: HTTPS The “normal” web protocol with a personal access token for authentication, a kind of restricted password SSH The “more traditional” file transfer protocol with a key pair for authentication On Mac and Linux, SSH is relatively straight forward, but you can use PuTTY to manage your SSH keys on Windows. I recommend you to create keys without an additional password (passphrase), because keys themselves are secure enough, and entering the passphrase becomes very distracting in the workflow. Public services like &lt;github.com&gt; and &lt;gitlab.com&gt; offer both methods, and you’ll find detailed setup guides in their help resources. After setting up authentication, manually entering passwords is rarely needed. Sometimes, only one of them is available on a server. The self-hosted NOWA gitlab only supports HTTPS, but no SSH. 3.3 Commit history A repository mainly contains a version history. In git terminology, A version is called a commit, so the history is often called commit history. Creating a new commit means introducing a set of project file changes to the history, each commit represents a full project state. The history is no collection of isolated snapshots, but a referential and differential structure. This also means that commits are rarely deleted. Rewriting and cleaning history is possible, but please consider commits as something that has happened in the past. We can of course revert our mistakes from the past, but that doesn’t rewrite the past. Git has the sophisticated concept of a currently active commit in a repo, this “state variable” is called HEAD in Git terminology. The next new commit is always based on the active commit which HEAD is pointing to. After creating a new commit, HEAD is set to that new commit. So we have an advancing HEAD state. In the simplest case, this mechanism builds a sequence of commits. The HEAD variable could even be omitted and the most recent commit could always be used as the base commit for the next new commit. But the user can deliberately set HEAD to any commit in the history, and this commit will act as the base for the next new commit. As a consequence, multiple commits can be based on the same commit because the user can return to that commit and create new commits repeatedly. This results in a diverging tree graph structure. In a tree graph, the root is reachable from every node. This can lead to the impression of linearity when you follow a path from leaf to root, but in fact, the graph can have diverged. As long as you don’t deliberately change the active commit state, you build simple commit sequences without divergence. Finally, there is a special kind of commit which can be based on two commits. As a consequence, diverged paths can merge again. The following example diagram illustrates how a result of this process can look like. If you open the cloned repo in Git Tower, you can inspect its commit history as a graph in the History view. The commits are shown in reverse-chronological order. Each commit shows its ID, date, author, and a descriptive message. Selecting a commit reveals the file changes associated with this commit. You can switch from list view to tree view which displays the full project state instead of the changes. On the command line, use the git log &lt;id&gt; command to list commits, and git show &lt;id&gt; to view exactly one commit. These commands can be seen as query tools for selecting and subsetting commits and the displayed information of each commit. The Git Pro book provides a short summary of using git log and its options. If no ID is given, the active commit is used by both commands. Try e.g. git log --stat or git log --oneline to customize your log output, or git log &lt;file/path&gt; to subset the commits affecting a given file or folder. The unique ID is created by Git and used in Git operations where a determined commit has to be referenced, e.g., if you want to select or inspect a commit. Date and author are set automatically, but both can be customized. We will customize the author in the workflow chapter. The messages are provided by the user for each commit, they make the history meaningful and expressive. When you create a commit, you have to think of a message which describes the introduced set of file changes in a more semantic way. The flow diagram above is composed of this kind of messages. 3.4 Navigating the tree: Tags and branches When the history grows and diverges, the user can quickly get lost in the tree graph. Switching between parallel paths requires the user to find the leaf of the target path. Setting HEAD back to an older commit in order to diverge requires the user to find the correct commit again and again. In a graphical tool, this would be possible by visual inspection, but cumbersome. On the command line, working productively would be nearly impossible, because you would always have to query and enter the alphanumeric commit IDs. Git was originally developed for the command line, so a second important layer has been built into Git for navigational purposes: tags and branches. These behave like bookmarks that are created by the user to label important commits in the graph with a meaningful name. Both can be passed to the Git commands in place of the commit IDs to view the history, set HEAD to a desired commit, and similar operations. In fact, they are landmarks for the graph. Users normally work with this layer, and rarely have to directly work with the raw IDs. It is much more common to modify and delete these landmarks than it is for commits, like you can change your opinion about the importance of historical events. 3.4.1 Branches Branches are made to label the leaf commit of tree paths. We have already seen the advancing nature of HEAD. HEAD stores the ID of a commit and is advanced by creating a new commit. This advancing behavior is the outstanding feature of branches. Additionally, branches have a name which is defined by the user, and branches can also reference the name of another branch instead of a commit ID. Technically, HEAD is a special branch named HEAD, a concrete example of the branch concept. HEAD usually doesn’t directly reference a commit, but a branch which references a commit. Users can deliberately set HEAD to a branch, marking this branch as active branch. Switching between branches is extremely fast, because it doesn’t need to copy any data files, it’s just setting a reference. If HEAD references a branch, advancing is forwarded to that branch instead of advancing HEAD itself. Creating a new commit advances the active branch to the new commit and leaves HEAD set to the branch. Git Tower displays the branches of a repo in the Branches section of the sidebar. You can linearly follow a branch to the root, and get the impression of separate contexts. An important detail to note is that the History view contains no commits that are not reachable by a branch or tag. On the command line, use the git branch command to list the branches in the repo. Then run git log &lt;branch&gt; or git show &lt;branch&gt; to inspect the history via branches. Please don’t be confused by some branches appearing also in the Remotes section of Tower’s sidebar. Due to its distributed architecture, Git distinguishes branches into local and remote branches. The local branches are the working branches as described above, remote branches reflect the current branch state of the respective remote repository. Git doesn’t push all local branches automatically, but a local branch is deliberately pushed by the user. Pushing a local branch pushes all reachable commits from this branch and updates the remote branch. A common workflow is creating many local branches that will never be shared. This enables users to distinguish between their personal working branches and those in a central collaboration repo. 3.4.2 Tags Tags are labels for important commits in the graph. They exist in two implementation flavors: Lightweight tags Like branches, these have a name and store the ID of a commit, and they can be easily created and deleted. They are useful as temporary labels to simplify the workflow, and they are deliberately uploaded by the user. Annotated tags These are exactly like commits without change data. They become part of the commit graph, have a predecessor commit, and have metadata and messages, so they should be used to create more final landmarks in the graph that will never change. Releases are a typical example for annotated tags. In Git Tower, tags are shown in the sidebar below the branches. On the command line, run git tag to list the local tags in the repo. 3.5 Comparing commits How can the changes introduced by a commit be inspected? You have certainly worked with the track changes feature of MS word. Word doesn’t have to be tool agnostic and simply tracks your actions. In Git, the commits with descriptive messages fulfill the role of meaningful semantic actions. That’s why commit messages are often written in an imperative style (Rewrite chapter 3). Being tool agnostic, Git doesn’t track what the commit authors did in their productivity tools. In order to report which changes were introduced by a commit, Git compares the two project states of the commit and its predecessor, and represents the difference in a standardized output format as changes which affect files and file content. The format is just a representation or interchange format to communicate changes, not the internal storage format used by Git. File changes Files in the project can be added, modified, or deleted. Text file content changes Git uses a textual representation of text changes by default, the unified diff format Lines within text files can be added or deleted in this diff format. Diff prepends added and removed lines with plus and minus signs. Modified lines are composed of a deletion and an addition. Binary file content changes For binary files like PDF, images, or Office files, Git unfortunately doesn’t have a representation of file content changes. Graphical (diff) tools for comparing file content side by side can integrate with Git, but this course concentrates on the traditional textual diff. IDE programs like VS Code or IntelliJ also contain their own graphical diff tool. You’ll find many online resources about diff tools and Git. In Git Tower, file changes are displayed next to the selected commit in the history. Files can be expanded to show their diff. On the command line, git show &lt;id&gt; outputs the diff of a given commit. One more implication of this architecture is that Git can compare a commit to any other commit, not only to its predecessor. Comparing a commit to its predecessor can be seen as the most frequent special case of this more general approach. It uses the same comparing mechanisms as above and reports the difference in terms of changes or diff representations. "],["practice-history.html", "4 Practice: History 4.1 Exploring commits and their file changes 4.2 Exploring commits and their associated project state 4.3 Interpreting file content changes 4.4 Congrats", " 4 Practice: History Make sure you have cloned and opened the course repo in Git Tower. The practice questions in this chapter can be answered from the History and branches view. You could also browse the repo on Github which is also a common strategy for pure history inspection. If you want to use the command line, some exercises can be a bit more challenging to solve. 4.1 Exploring commits and their file changes In Git Tower, you can use the filter field and the file context menu for subsetting the history by commit or file/folder. On the command line, git log with some additional options is sufficient. How many commits changed the README.md file in the repo’s root folder? Which files have been affected by the 0d45a0081fe1db38fd4964a23ba4b4bfcec4987b commit? Which is the newest commit of the origin/example_mirror_duet branch? 4.2 Exploring commits and their associated project state Please select the origin/example_mirror_duet branch. The rest of this chapter will refer to this branch. Git Tower lets you view the file list next to the commits as changeset or as tree. In the last section, only the changesets were needed. Please try to make use of both views to complete the exercises in this section. How many files are contained in the examples/mirror-duet folder of the newest branch commit? Select an older commit in the branch, and observe how the folder changes. Please have a look into the readme file to get a quick overview of the example project. Please find the commit where the example folder has been added. In order to get a more visual impression of the example project’s development, please open the PDF document in some of the commits from old to newest. You could also open the Lilypond source file or try to play the midi file, if you prefer those. 4.3 Interpreting file content changes Until now, you were exploring the history on commit and file level. In this section, you have to answer some questions about file content changes by reading the diff. Can you verbalize from the diff what I had to do in the mirror-duet.ly file in order to bring the duet into line with the edition by Schott Music? When I added the music for the 2nd violin, I added an additional fix to the score environment almost at the end of the file. Can you identify it? In the “Clean source file” commit of the branch I did some housekeeping on the source file where the actual content didn’t change anymore. Can you verbalize what I did? Why does the diff contain so many removed and added lines of music, although the meaning didn’t change? In this example project, I have added the output files to each commit, so you can view the differences without having to install the lilypond compiler. A rule of thumb is not to commit build artefacts because they can be reclaimed, but it can be reasonable to keep them in version control. Please think about pros and cons for committing artefacts 4.4 Congrats If you have reached this section, you should … … know the most important git concepts … be able to browse an existing git repo … be able to answer specific questions about the development of a project versioned with Git "],["workflow.html", "5 Workflow 5.1 Setup 5.2 Creating a git repository 5.3 Creating new commits", " 5 Workflow After learning to explore existing git repos, being productive with git is the next objective. This chapter describes the workflow of integrating your changes into a new or existing project. 5.1 Setup Before you create your first commits, you have to configure a few settings: Commit identity Your name and email address you want to be associated with your commits Editor The text editor that should be opened when Git asks you for text input, e.g., commit messages. Default initial branch The default name of a branch initially created after a new repo has been created. Git has a subcommand named git config which is used to customize Git’s behavior on your local machine via settings. There are many settings, and a setting can be configured for a single repo, or as a (global) user default which is used for every repo where this setting isn’t configured. Here we will just set some user default settings. Config settings are never persisted to the history or shared with collaborators, because they customize your working environment. Git Tower doesn’t provide a full interface to the config settings, and you partially need the command line. # Display full user config git config --global -l # Display local repo config with merged global config git config -l 5.1.1 Commit identity This identity is persisted into each of your commits and visible for everyone who can see your commits, thus it should be properly set. It’s just descriptive metadata, Git itself doesn’t verify your email. The actual identity data becomes more critical in conjunction with hosting platforms like Github or Gitlab, because the platforms offer more security features and use the email to attribute your commits to your platform account. Github provides anonymized email addresses for users who don’t want to expose their personal email. In Git Tower, you can configure your user name and email via Preferences -&gt; Git Config. As a convenience feature provided by Git Tower, you can also store multiple identities under Preferences -&gt; User Profiles, e.g., for work and private commits. On the command line, use these commands to configure your identity: # Please replace the identity values with your identity git config --global user.name &quot;Tamara Cook, M.Sc.&quot; git config --global user.email tamara.cook@uni-marburg.de # To display the current values, execute without second argument git config --global user.name git config --global user.email 5.1.2 Editor Git needs the program path of your preferred text editor. When Git asks for text input, it opens this editor in a special mode where you can enter text, and Git waits until you confirm your input by saving and closing the document. In Git Tower, this setting will rarely be used. If you’d never use the command line, you could skip this step, but it is recommended as a precaution. Please configure one of the editors listed in this appendix of Git Pro (table 4). 5.1.3 Default initial branch When a new repository is created, Git also creates an initial branch as a starting point to work with immediately. This branch often represents the current stable version of the project and is set as HEAD on hosting platforms like Gitlab or Github. This affects the active branch after cloning a repo, and how a repo is displayed on the web page. Historically, it’s default name has been “master,” but a cultural change has occurred in the tech community which strives to replace the master/slave terms in technical speech with more neutral and politically inclusive ones. Git and platforms like Gitlab and Github support this movement and have chosen “main” as the new default name for initial branches. The migration process is inevitable but still in progress, that’s why explicitly configuring the default name via user config setting is part of the first git setup for the time being: # Create new repos with a initial branch called main git config --global init.defaultBranch main 5.2 Creating a git repository A repository is just a hidden .git directory in the working copy root, and Git can add a pristine repository to any physical directory, be it empty or an existing project. This pristine state of the new repository can be viewed as the root of the history graph, a virtual zero commit. Afterwards, Git automatically creates and activates an initial branch one can immediately work with. 5.2.1 Git Tower Go to Repositories view and hit “Create new local repository” in context menu. Create a new directory or choose an existing one where you want to create a Git repository. The new repository is added to the Repositories view. 5.2.2 Command line Create a new directory or choose an existing one that you want to turn into a Git repository. Open a terminal in this directory. Create a new git repository by running git init. 5.2.3 Hosting platform If you want to connect your repo with a hosting platform, you have to create a new repository on the respective platform. Please look for “Create new repository” or similar functions. You’ll be asked for some metadata and to set the repo name and group which determines the repo URL. You have two alternative strategies for the actual git repo: Let the platform initialize the repo and clone it afterwards. This is appropriate for creating completely new projects. Skip initializing, add the new URL as remote to an existing local repo, and push the initial branch. If you want to populate an existing local repo, or need more control over the initialization process, this is the right choice. 5.3 Creating new commits We already know that a new commit contains the differences to the currently active commit (HEAD), and that the new commit becomes HEAD after it has been created. So the standard workflow is creating a sequence of commits during work. Creating commits is an iterative explicit workflow which may need some habit building, but can be a tool for structuring one’s thoughts and making work results visible. Edit your working copy View and select changes in the working copy compared to the current HEAD Create new commit 5.3.1 Editing the working copy This is your actual work with you usual productivity tools. Your project folder contains a (maybe still pristine) copy of HEAD, and here you can make your improvements. Physical files and lines can be added, modified, and deleted. After you have finished a task or something similar that can be suitable for a commit, it’s time to proceed to the next step. 5.3.2 Viewing and selecting changes in the working copy Git doesn’t track the user’s working actions, but it just compares the working copy to HEAD and shows the differences in the diff format you have already seen in the history section. This differential approach is an important building block which makes Git tool agnostic. It can be helpful to imagine this as an additional virtual location where the unversioned changes are collected in a change set. The change set depends on the working copy, and it is a good habit to observe the change set during work. If you select and commit some changes, these changes disappear from the change set and flow into the history where they become versioned. In Git Tower, the Working copy view is made for preparing and creating commits. The Tower help provides overview sections about inspecting changes and selecting changes. You can select either complete files via checkbox, or partial files where a change occurred. If you are sure that you want to select everything, simply hit the “Stage all” button and you are ready to commit. Noticeably, Git has weird terms for many usual concepts, and staging is the term for selecting changes for the next commit. On the command line, Git provides some subcommands for viewing and selecting changes: git status lists the changed files. git diff &lt;filepath&gt; shows the diff view of the given file. git add &lt;filepath&gt; stages a file. git restore --staged &lt;filepath&gt; unstages a file. The status output differentiates between tracked files and untracked files: Tracked files were already committed to the history, but the working copy contains added or deleted lines. Untracked files were never committed before, but staging and committing them adds them to the history which turns them into tracked files. You might also be interested in [interactive staging] by Git Pro for the partial file selection. 5.3.3 Creating a new commit This is the transition of the selected changes into the history. After figuring out your change selection, enter a well-formed commit message, and hit Commit. The committed changes are now versioned and should disappear from the change list. On the command line, execute git commit to create a commit from the selection. Your text editor will open and wait for the commit message being saved. You can also run git commit -m \"My non-interactive message\" to skip the editor step. 5.3.4 Populating the working copy If we want to work on another branch or change HEAD for another reason, we would possibly see many pointless changes in the change set. we need a way to restore history commits to the working copy. Git offers the checkout command to synchronize the working copy with the history. This command actually throws two concepts together (switch HEAD and restore files), that’s why its usage can be a bit confusing. Please examine your change set always before using checkout, because unversioned changes can get lost or Git will refuse to checkout. Checking out a file means keeping HEAD as is, and just restoring the files in the given path from the HEAD commit. This is commonly used for discarding unversioned changes. Checking out a branch, tag, or commit means setting HEAD to that commit, and overwriting the working copy with the state corresponding to HEAD. This should only be done if the working copy is clean. You will encounter the checkout command in more circumstances, because it has a pletora of additional shortcut options. "],["practice-workflow.html", "6 Practice: Workflow 6.1 General workflow 6.2 Suggested improvements", " 6 Practice: Workflow In this section, you will practice the git editing workflow by contributing to a small Matlab example project which contains a formatting function for empirical numbers. Don’t worry, the project should be simple enough to get the exercises done, even if you’re not used to Matlab. Please make sure you have successfully finished the first git setup. The example project is located in the examples/empirical-round directory of our main git project. It’s readme file provides a brief overview of the project, its files and their purposes. Now, it’s your task to make some minor improvements to the project. You can fix issues that you found yourself, otherwise choose from the suggestions below. 6.1 General workflow Please try to follow these steps when you make an improvement: Choose an issue or area you want to work on. Create a branch from the main branch with a recognizable name, and checkout the new branch: git checkout -b fix_tests main. Make your file modifications. Try to find multiple modifications which can be grouped into one commit, e.g., spelling errors. Stage (select) the affected files: git add path/to/file or git add . to stage everything. Commit your changes: git commit. Push your branch to your fork: git push origin fix_tests 6.2 Suggested improvements These suggestions are intended to quickly provide you with some todos, but you can of course create your own issues. 6.2.1 Readme file README.md can be improved at some places. You can use any text editor for editing. In the first paragraph, the topic introduction is very short. Maybe you can divide it into a topic and a project paragraph, and improve the topic introduction by providing a more detailed explanation or motivation. The sentence in line 9 is missing the word “function” before or after format_emp. 6.2.2 Matlab compatibility The code should run with Matlab, but comments are introduced using the # character. This is allowed in Octave for shell compatibility, but not in Matlab. You can make the comments compatible to Matlab by replacing # with % characters. 6.2.3 Variable collision Both functions take an input parameter named e, but e is already a global constant. This can lead to weird behavior. You can fix this problem by renaming these inputs to something unique, e.g. se. Don’t forget to rename every occurrence of e, not just the function signature. 6.2.4 Function documentation Functions meant to be called by users should have at least a short documentation comment. You can add a documentation comment to the format_emp function below the signature line which looks like this: % Format empirical numbers % printed = format_emp(x, e) rounds and formats the measured value x according to the measurement error e. 6.2.5 License file The license is mentioned in the readme file, but the project doesn’t contain any license file. You can add a license file by following the instructions for the MIT license (section “How to apply this license”) by &lt;choosealicense.com&gt;. Please use “Tamara Cook” as copyright holder, and of course don’t forget to commit the license file. 6.2.6 Tests Currently, function calls of format_emp with one input isn’t tested. You can activate it and get it running by making two small modifications in tests.csv and format_emp.m: The se_exp variable is incorrect in the first test case. The function call with one input is missing in the for loop of the test block after line 28. The function has to be called only with se, and the result is expected to be se_exp. Please copy line 28 and modify accordingly. "],["organization-1.html", "7 Organization 7.1 Agenda", " 7 Organization In this session, the scope extends to collaboration on Gitlab projects. These topics are covered: Connecting Git repos with Gitlab and uploading work for backup Customizing Git repos for the project content Sharing Gitlab projects with co-workers for review Collaborating with co-workers on a shared Gitlab project 7.1 Agenda "],["references.html", "References", " References Chacon, S., &amp; Straub, B. (2014). Pro git (2nd ed.). Springer Nature. "]]
